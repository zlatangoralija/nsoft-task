<p align="center"><img src="https://laravel.com/assets/img/components/logo-laravel.svg"></p>

## NSoft - Seven Essential Services Recruiting Task
Welcome. This is my solution for the given task above. The project was developed using Laravel PHP framework. It contains two services: Service A and Service B, which use a messaging system that connects them to single business process. Both services are invoked through routes, and [Postman](https://www.getpostman.com/) is used to test and run those services.  All project parts, installation, how to set-up and how to run specific services and tasks will be separately documented down below.


## Table of contents
1. [Instalation](#instalation)
2. [Docker](#docker)
3. [Service A](#service-a)
4. [HTTP API](#http-api)
5. [Messaging API](#messaging-api)
6. [Service B](#service-b)
  
<a name="instalation"></a>
## Instalation
After cloning or downloading project files, first thing you have to do is to install composer, which is a tool for dependency management in PHP, by running this command in terminal:
```php
composer install
```

After composer is installed, the application key has to be generated by running this command in terminal:
```php
php artisan key:generate
```

Now, project is set-up for further configuration. This project is using MySQL database, so before we continue, go to *phpmyadmin* in your browser (*localhost:8080*) and create an empty database. After that, rename the .env-example file to just .env and enter your database configuration, like below:
```php
DB_CONNECTION=mysql
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=your_database_name
DB_USERNAME=your_mysql_username
DB_PASSWORD=your_mysql_password
```
> Note: Use *root* username and password. Root user should have all privileges.

<a name="docker"></a>
## Setting up Docker containers
This project is "Dockerable", so you have to set up Docker first, in order to run services. This project uses [Laradock](https://laradock.io/), which is a full PHP development environment for Docker. Laradock contains all files necessary to install and run containers. In order to do that, navigate to "laradock" folder, which includes all pre-configured and pre-packaged Docker Images. 
```
cd laradock
```

Since all Docker Images all pre-configured, you just have to specify which containers you need to run, in this case: 
- MySQL, 
- RabbitMQ,
- apache2,
- phpmyadmin

One more thing you have to do before running containers, is to rename the `laradock/env-example` to `.env`, and enter your same database configuration again: 
```
MYSQL_VERSION=5.7
MYSQL_DATABASE=your_database_name
MYSQL_USER=your_mysql_user
MYSQL_PASSWORD=your_mysql_password
MYSQL_PORT=3306
MYSQL_ROOT_PASSWORD=root
MYSQL_ENTRYPOINT_INITDB=./mysql/docker-entrypoint-initdb.d
```

>Note: I'm using MySQL version 5.7. because the newest version is not yet properly configured with Docker and I got some errors with that latest version.

Now, Docker containers are ready to run. Make sure you are in laradock/ directory and that Docker is running on your machine:
```
docker-compose up -d mysql apache2 rabbitmq phpmyadmin
```
When everything is pulled and installed, you can check if containers are running properly, with the given command below. Everyhting should have the `state` of `up`. Also, you can test it by opening your browser and going to "localhost/public".
```
docker-compose ps
```

<p align="center"><img src="https://i.imgur.com/SlGaomJ.png"></p>

After that, you have to use *workspace* Image, which is development environment:
```
docker-compose exec workspace bash
```
> Note: If you for some reason get an "*php_network_getaddresses: getaddrinfo failed*" error, just rebuild mysql container with following command: *docker-compose build --no-cache mysql* and do the *docker-compose up* command again

If everything is set-up correctly, we can now migrate the tables, which will create *account* entity in given the database in the *.env* file, with two properties, **balance** and **updatedAt**. Initial **balance** is set at **0** and initial **updatedAt** is set at **NULL** by default. To migrate tables, use following command:
```
php artisan migrate
```
Database can by inspected by going to "*localhost:8080*" in your browser, which will open *phpmyadmin*. Now you have everything set, and you can proceed to Services documentation, which will contain all necessary information about purposes, set-up and running.

<a name="service-a"></a>
## Service A
Service A is the first part of this project. This service is used to generate message for the Service B. For this Service, I used a single **POST** API route, which is used to generate a message, containing money data, to Service B, using [RabbitMQ](https://www.rabbitmq.com/) message broker. This route leads to Service A controller, where all the logic is located.

As noted earlier, I used *Postman* to send this request. Create new **POST** request and enter following route and parameters:

<p align="center"><img src="https://i.imgur.com/ohuMXY5.png"></p>

After you hit *Send*, message will be sent to message broker que, and HTTP payload of sent data will we displayed below. For the message broker, I used [CloudAMQP](https://www.cloudamqp.com/) RabbitMQ menager, where I could track messages and ques created by service A. The previous message looks like this, and it's ready to be consumed and saved to database:

<p align="center"><img src="https://i.imgur.com/Q1PyIaw.png"></p>

<a name="http-api"></a>
### HTTP API
HTTP receives and shows HTTP payload that is sent from Postman. Payload's amount is set as decimal representation, and API accepts only payloads that are in acceptable range. Valid request will generate status 200 and the Service A process will continue, invalid ones will generate status 400, and whole process stops. HTTP API logic is located in Service A controller.

<a name="messaging-api"></a>
### MESSAGING API
MESSAGING API is used to send previous HTTP payload to a messaging broker. Amount is set as minimal currency denomination representation. Messaging API logic is located in Service A controller as well.

<a name="service-b"></a>
## Service B
Service B is the second part of this project. It has a little different approach than the previous service. Main part of this service is to receives/consumes the data from message broker, and save it to database.This service has two parts:
- Consumer.php script 
- API consumer route

*Consumer.php* script is run through terminal, and it accepts message from message broker, and saves it to a file. In order to run this script, make sure you're still using *workspace* Image:
```
php src/consumer.php
``` 

>Note: While this script is running, it will consume all the messages that are sent from Service A, one by one. You can repeat sending and receiving messages with Postman.

API consumer route is another *POST* API route, that leads to Service B controller. Serivce B controller is used to read data from the file, where it was previously saved to. After it reads that data, it updates previous *balance* amount. To invoke Service B, create another POST request in Postman:
<p align="center"><img src="https://i.imgur.com/FdOCg3S.png"></p>

The last part of this project is a single HTTP API route that shows current account balance and the time it was last updated. Create a new GET request in Postman, like in example:
<p align="center"><img src="https://i.imgur.com/sMXZWI3.png"></p>

